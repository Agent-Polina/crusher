У пользователя есть возможность производить преобразования над мутированными данными перед отправкой их приложению с помощью скриптов пост-обработки данных.
В `Crusher` есть возможность использования пользовательских скриптов пост-обработки данных.

Такой скрипт представляет из себя плагин на языке программирования `Python`.

Для использования пользовательского плагина пост-обработки данных необходимо выполнить следующие действия:
1. написать плагин;
2. добавить плагин в конфиг-файл для запуска `Crusher`;
3. запустить `Crusher` с этим конфиг-файлом.

### 1. Написание плагина
Плагин представляет из себя `.py` файл со следующими необходимыми компонентами:
* функция инициализации `initialization()`;
* класс пост-обработки.

#### Функция `initialization()`
Функция `initialization()` возвращает класс пост-обработки, реализованный в плагине.

Пример функции `initialization()`:

```python
def initialization():
    return PostProcess
```

#### Класс пост-обработки
Имя класса должно соответствовать тому, что возвращает функция `initialization`.

##### Метод пост-обработки
В классе необходимо релизовать метод `post_processing`, который принимает в качестве аргумента массив байт (`bytearray`) - буфер, который передаёт ядро `Crusher` для мутаций, и возвращает также массив байт.

Данный метод должен обязательно содержать следующий код (для правильной его инициализации в `Crusher`):
```python
def post_processing(self, data=None):
    if data is None:
        return 42
```

Предполагается, что в остальной части тела метода проводятся манипуляции над `data` и возвращается новый массив байт.
Однако, использование `data` не является обязательным.

### 2. Добавление пост-обработчика в конфиг-файл для `Crusher`
Конфиг-файл для `Crusher` (наряду с аргументами командной строки) позволяет более тонко настраивать его работу. Используется формат `JSON`.

Для использования нового скрипта пост-обработки при фаззинге нужно добавить полный путь к нему в поле `"post-processing"` в конфиг-файле.

Важно помнить, что в директориях `queue` внутри директории с результатами работы фаззера будут храниться данные до пост-обработки.
Т.е. для воспроизведения, например, запусков с некоторыми тесткейсами из `queue`, над данными из соответствующих директорий нужно произвести преобразования из метода `post_processing` и только после этого подать на вход приложению.
Дело в том, что после пост-обработки размер файла может заметно вырасти, например, после добавления множества заголовков. Чтобы избежать нерационального использования дискового пространства, файлы в `queue` записываются без пост-обработки.

При этом в директориях `crashes` и `hangs` записаны файлы уже после пост-обработки, на которых можно воспроизвести креши/зависания приложения без дополнительных преобразований.
Крешей и зависаний обычно на порядки меньше (если они вообще есть), чем путей, поэтому они занимают меньше места на диске.
И именно они представляют наибольший интерес. Поэтому (для удобства воспроизведения) файлы, приведшие к крешам/зависаниям - записываются уже с пост-обработкой.

Пример конфиг-файла:
```json
{
	"post-processing": "/path/to/post-proc.py"
}
```

### 3. Запуск `Crusher`
Пример запуска `Crusher` с пользовательским скриптом пост-обработки, где `config.json` - конфиг-файл:
```shell script
/path/to/crusher/bin_x86-64/fuzz_manager --start 4 -i in -o out --config-file config.json -- ./test @@
```

Также можно запустить `Crusher` со скриптом пост-обработки и без конфиг-файла.
Для этого в командной строке нужно использовать опцию `--post-processing`, передавая ей в качестве аргумента путь до скрипта пост-обработки:

```shell script
/path/to/crusher/bin_x86-64/fuzz_manager --start 4 -i in -o out --post-processing post-proc.py -- ./test @@
```

Пример скрипта пост-обработки - файл `post-proc.py`.

Пример конфиг-файла - файл `config.json`.
